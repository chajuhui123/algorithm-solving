사실 이분탐색 문제로 분류 되어 있었기에, 한 번에 이분탐색 알고리즘을 작성한 것이지 아니었다면 고민하는데 좀 더 오랜 시간을 소요했을 것 같다.

이분 탐색 알고리즘을 사용하기에 `시작점`,`중간점`,`끝점` 필요하다. 중간점과 목표값을 비교하면서, 시작점과 끝점을 상황에 맞게 변경하는 알고리즘이다.

만약 찾고자 하는 값이 중간점보다 작다면 끝점을 `중간점-1` 로 변경하고, 찾고자 하는 값이 중간점보다 크다면 시작점을 `중간점+1` 로 변경한다

해당 문제에서는 시작점을 보통 이분탐색 문제 처럼 0으로 두었고,
끝점은 심사가 가장 오래걸리는 시간으로 모든 사람이 심사를 받았을 때의 값으로 두었다.

따라서 **처음에 times를 오름차순 정렬하여, 마지막 값으로, 가장 오래 걸리는 심사 시간**을 구한다.

이제 이 값을 제한시간으로 둔다. 제한시간 안에 심사를 받을 수 있는 인원을 구해본다. 그리고 이 값을 우리가 입력받은 n값과 비교하여 이분 탐색을 진행한다.

```js
function solution(n, times) {
  times.sort((a, b) => a - b); // times 오름차순 정렬

  let start = 0; // 시작점
  let end = times[times.length - 1] * n; // 끝점 (가장 오래걸리는 심사관에게 모두가 심사받았을 때가 최댓값 = 끝점)
  let mid = Math.floor((start + end) / 2); // 중간점

  // 시작점이 끝점보다 작거나 같은 경우
  while (start <= end) {
    // 시간 제한을 두고 심사 가능한 인원 수를 세는 로직
    const count = times.reduce(
      (result, cur) => result + Math.floor(mid / cur),
      0
    );

    if (count >= n) {
      end = mid - 1; // 탐색 가능한 인원이 입력받은 인원보다 크다면, 더 작은 왼쪽 탐색
    } else {
      start = mid + 1; // 탐색 가능한 인원이 입력받은 인원보다 작다면, 더 큰 오른쪽 탐색
    }
    mid = Math.floor((start + end) / 2);
  }
  return start;
}
```
